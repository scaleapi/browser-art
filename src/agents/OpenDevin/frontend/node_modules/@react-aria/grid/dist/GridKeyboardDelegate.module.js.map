{"mappings":";;;AAAA;;;;;;;;;;CAUC;;AAmBM,MAAM;IAqBD,OAAO,IAAa,EAAE;QAC9B,OAAO,KAAK,IAAI,KAAK;IACvB;IAEU,MAAM,IAAa,EAAE;QAC7B,OAAO,KAAK,IAAI,KAAK,SAAS,KAAK,IAAI,KAAK;IAC9C;IAEQ,WAAW,IAAmB,EAAE;YACK;QAA3C,OAAO,IAAI,CAAC,gBAAgB,KAAK,SAAU,CAAA,EAAA,cAAA,KAAK,KAAK,cAAV,kCAAA,YAAY,UAAU,KAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,KAAK,GAAG,CAAA;IACrG;IAEU,gBAAgB,OAAa,EAAE,IAAiC,EAAE;QAC1E,IAAI,MAAM,WAAW,OACjB,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,WAC7B,IAAI,CAAC,UAAU,CAAC,UAAU;QAE9B,MAAO,OAAO,KAAM;YAClB,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC;YACnC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,SAAU,CAAA,CAAC,QAAQ,KAAK,KAAI,GAC/C,OAAO;YAGT,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC;QACrC;IACF;IAEU,YAAY,OAAa,EAAE,IAAiC,EAAE;QACtE,IAAI,MAAM,WAAW,OACjB,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,WAC5B,IAAI,CAAC,UAAU,CAAC,WAAW;QAE/B,MAAO,OAAO,KAAM;YAClB,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC;YACnC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,SAAU,CAAA,CAAC,QAAQ,KAAK,KAAI,GAC/C,OAAO;YAGT,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC;QACpC;IACF;IAEA,YAAY,GAAQ,EAAE;QACpB,IAAI,YAAY,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC;QACxC,IAAI,CAAC,WACH;QAGF,8DAA8D;QAC9D,IAAI,IAAI,CAAC,MAAM,CAAC,YACd,MAAM,UAAU,SAAS;QAG3B,qBAAqB;QACrB,MAAM,IAAI,CAAC,WAAW,CAAC;QACvB,IAAI,OAAO,MAAM;YACf,8EAA8E;YAC9E,IAAI,IAAI,CAAC,MAAM,CAAC,YAAY;gBAC1B,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC;gBACnC,OAAO,CAAA,GAAA,iBAAS,EAAE,CAAA,GAAA,oBAAY,EAAE,MAAM,IAAI,CAAC,UAAU,GAAG,UAAU,KAAK,EAAE,GAAG;YAC9E;YAEA,gCAAgC;YAChC,IAAI,IAAI,CAAC,SAAS,KAAK,OACrB,OAAO;QAEX;IACF;IAEA,YAAY,GAAQ,EAAE;QACpB,IAAI,YAAY,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC;QACxC,IAAI,CAAC,WACH;QAGF,6DAA6D;QAC7D,IAAI,IAAI,CAAC,MAAM,CAAC,YACd,MAAM,UAAU,SAAS;QAG3B,yBAAyB;QACzB,MAAM,IAAI,CAAC,eAAe,CAAC;QAC3B,IAAI,OAAO,MAAM;YACf,kFAAkF;YAClF,IAAI,IAAI,CAAC,MAAM,CAAC,YAAY;gBAC1B,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC;gBACnC,OAAO,CAAA,GAAA,iBAAS,EAAE,CAAA,GAAA,oBAAY,EAAE,MAAM,IAAI,CAAC,UAAU,GAAG,UAAU,KAAK,EAAE,GAAG;YAC9E;YAEA,oCAAoC;YACpC,IAAI,IAAI,CAAC,SAAS,KAAK,OACrB,OAAO;QAEX;IACF;IAEA,cAAc,GAAQ,EAAE;QACtB,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC;QACnC,IAAI,CAAC,MACH;QAGF,oDAAoD;QACpD,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO;YACpB,IAAI,WAAW,CAAA,GAAA,oBAAY,EAAE,MAAM,IAAI,CAAC,UAAU;YAClD,OAAO,IAAI,CAAC,SAAS,KAAK,QACtB,CAAA,GAAA,kBAAU,EAAE,UAAU,GAAG,GACzB,CAAA,GAAA,mBAAW,EAAE,UAAU,GAAG;QAChC;QAEA,qDAAqD;QACrD,kCAAkC;QAClC,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO;YACrB,IAAI,SAAS,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,SAAS;YACnD,IAAI,WAAW,CAAA,GAAA,oBAAY,EAAE,QAAQ,IAAI,CAAC,UAAU;YACpD,IAAI,OAAO,IAAI,CAAC,SAAS,KAAK,QAC1B,CAAA,GAAA,iBAAS,EAAE,UAAU,KAAK,KAAK,GAAG,KAClC,CAAA,GAAA,iBAAS,EAAE,UAAU,KAAK,KAAK,GAAG;YAEtC,IAAI,MACF,OAAO,KAAK,GAAG;YAGjB,4CAA4C;YAC5C,IAAI,IAAI,CAAC,SAAS,KAAK,OACrB,OAAO,KAAK,SAAS;YAGvB,OAAO,IAAI,CAAC,SAAS,KAAK,QAAQ,IAAI,CAAC,WAAW,CAAC,OAAO,IAAI,CAAC,UAAU,CAAC;QAC5E;IACF;IAEA,aAAa,GAAQ,EAAE;QACrB,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC;QACnC,IAAI,CAAC,MACH;QAGF,mDAAmD;QACnD,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO;YACpB,IAAI,WAAW,CAAA,GAAA,oBAAY,EAAE,MAAM,IAAI,CAAC,UAAU;YAClD,OAAO,IAAI,CAAC,SAAS,KAAK,QACtB,CAAA,GAAA,mBAAW,EAAE,UAAU,GAAG,GAC1B,CAAA,GAAA,kBAAU,EAAE,UAAU,GAAG;QAC/B;QAEA,yDAAyD;QACzD,kCAAkC;QAClC,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO;YACrB,IAAI,SAAS,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,SAAS;YACnD,IAAI,WAAW,CAAA,GAAA,oBAAY,EAAE,QAAQ,IAAI,CAAC,UAAU;YACpD,IAAI,OAAO,IAAI,CAAC,SAAS,KAAK,QAC1B,CAAA,GAAA,iBAAS,EAAE,UAAU,KAAK,KAAK,GAAG,KAClC,CAAA,GAAA,iBAAS,EAAE,UAAU,KAAK,KAAK,GAAG;YAEtC,IAAI,MACF,OAAO,KAAK,GAAG;YAGjB,4CAA4C;YAC5C,IAAI,IAAI,CAAC,SAAS,KAAK,OACrB,OAAO,KAAK,SAAS;YAGvB,OAAO,IAAI,CAAC,SAAS,KAAK,QAAQ,IAAI,CAAC,UAAU,CAAC,OAAO,IAAI,CAAC,WAAW,CAAC;QAC5E;IACF;IAEA,YAAY,GAAS,EAAE,MAAgB,EAAE;QACvC,IAAI;QACJ,IAAI,OAAO,MAAM;YACf,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC;YAC/B,IAAI,CAAC,MACH;YAGF,8DAA8D;YAC9D,kDAAkD;YAClD,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ;gBAChC,IAAI,SAAS,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,SAAS;gBACnD,OAAO,CAAA,GAAA,mBAAW,EAAE,CAAA,GAAA,oBAAY,EAAE,QAAQ,IAAI,CAAC,UAAU,GAAG,GAAG;YACjE;QACF;QAEA,qBAAqB;QACrB,MAAM,IAAI,CAAC,WAAW;QAEtB,2FAA2F;QAC3F,IAAI,AAAC,OAAO,QAAQ,QAAQ,IAAI,CAAC,MAAM,CAAC,SAAS,UAAW,IAAI,CAAC,SAAS,KAAK,QAAQ;YACrF,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC;YACnC,MAAM,CAAA,GAAA,mBAAW,EAAE,CAAA,GAAA,oBAAY,EAAE,MAAM,IAAI,CAAC,UAAU,GAAG,GAAG;QAC9D;QAEA,mCAAmC;QACnC,OAAO;IACT;IAEA,WAAW,GAAS,EAAE,MAAgB,EAAE;QACtC,IAAI;QACJ,IAAI,OAAO,MAAM;YACf,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC;YAC/B,IAAI,CAAC,MACH;YAGF,8DAA8D;YAC9D,iDAAiD;YACjD,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ;gBAChC,IAAI,SAAS,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,SAAS;gBACnD,IAAI,WAAW,CAAA,GAAA,oBAAY,EAAE,QAAQ,IAAI,CAAC,UAAU;gBACpD,OAAO,CAAA,GAAA,kBAAU,EAAE,UAAU,GAAG;YAClC;QACF;QAEA,oBAAoB;QACpB,MAAM,IAAI,CAAC,eAAe;QAE1B,yFAAyF;QACzF,IAAI,AAAC,OAAO,QAAQ,QAAQ,IAAI,CAAC,MAAM,CAAC,SAAS,UAAW,IAAI,CAAC,SAAS,KAAK,QAAQ;YACrF,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC;YACnC,IAAI,WAAW,CAAA,GAAA,oBAAY,EAAE,MAAM,IAAI,CAAC,UAAU;YAClD,MAAM,CAAA,GAAA,kBAAU,EAAE,UAAU,GAAG;QACjC;QAEA,mCAAmC;QACnC,OAAO;IACT;IAEQ,QAAQ,GAAQ,EAAe;QACrC,OAAO,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,WAAW,EAAE,IAAI,MAAM,CAAC,IAAI,QAAQ,IAAI,EAAE,CAAC;IACpF;IAEQ,YAAY,GAAQ,EAAQ;YAEzB;QADT,IAAI,IAAI,CAAC,MAAM,EACb,QAAO,6BAAA,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,kBAA1B,iDAAA,2BAAgC,IAAI;QAG7C,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC;QACxB,IAAI,MACF,OAAO,IAAI,CAAA,GAAA,WAAG,EAAE,KAAK,UAAU,EAAE,KAAK,SAAS,EAAE,KAAK,WAAW,EAAE,KAAK,YAAY;IAExF;IAEQ,gBAAwB;YAErB,0BAGF,mBAAA;QAJP,IAAI,IAAI,CAAC,MAAM,EACb,QAAO,2BAAA,IAAI,CAAC,MAAM,CAAC,WAAW,cAAvB,+CAAA,yBAAyB,WAAW,CAAC,MAAM;QAGpD,QAAO,YAAA,IAAI,CAAC,GAAG,cAAR,iCAAA,oBAAA,UAAU,OAAO,cAAjB,wCAAA,kBAAmB,YAAY;IACxC;IAEQ,mBAA2B;YAK1B,mBAAA;QAJP,IAAI,IAAI,CAAC,MAAM,EACb,OAAO,IAAI,CAAC,MAAM,CAAC,cAAc,GAAG,MAAM;QAG5C,QAAO,YAAA,IAAI,CAAC,GAAG,cAAR,iCAAA,oBAAA,UAAU,OAAO,cAAjB,wCAAA,kBAAmB,YAAY;IACxC;IAEA,gBAAgB,GAAQ,EAAE;QACxB,IAAI,WAAW,IAAI,CAAC,WAAW,CAAC;QAChC,IAAI,CAAC,UACH,OAAO;QAGT,IAAI,QAAQ,KAAK,GAAG,CAAC,GAAG,SAAS,IAAI,GAAG,IAAI,CAAC,aAAa;QAE1D,MAAO,YAAY,SAAS,CAAC,GAAG,MAAO;YACrC,MAAM,IAAI,CAAC,WAAW,CAAC;YACvB,WAAW,IAAI,CAAC,WAAW,CAAC;QAC9B;QAEA,OAAO;IACT;IAEA,gBAAgB,GAAQ,EAAE;QACxB,IAAI,WAAW,IAAI,CAAC,WAAW,CAAC;QAEhC,IAAI,CAAC,UACH,OAAO;QAGT,IAAI,aAAa,IAAI,CAAC,aAAa;QACnC,IAAI,QAAQ,KAAK,GAAG,CAAC,IAAI,CAAC,gBAAgB,IAAI,SAAS,CAAC,GAAG;QAE3D,MAAO,YAAY,SAAS,IAAI,GAAG,MAAO;YACxC,IAAI,UAAU,IAAI,CAAC,WAAW,CAAC;YAC/B,WAAW,IAAI,CAAC,WAAW,CAAC;YAE5B,0FAA0F;YAC1F,0CAA0C;YAC1C,IAAI,WAAW,MACb,MAAM;QAEV;QAEA,OAAO;IACT;IAEA,gBAAgB,MAAc,EAAE,OAAa,EAAE;QAC7C,IAAI,CAAC,IAAI,CAAC,QAAQ,EAChB,OAAO;QAGT,IAAI,aAAa,IAAI,CAAC,UAAU;QAChC,IAAI,MAAM,oBAAA,qBAAA,UAAW,IAAI,CAAC,WAAW;QAErC,6DAA6D;QAC7D,IAAI,YAAY,WAAW,OAAO,CAAC;QACnC,IAAI,UAAU,IAAI,KAAK,QACrB,MAAM,UAAU,SAAS;QAG3B,IAAI,aAAa;QACjB,MAAO,OAAO,KAAM;YAClB,IAAI,OAAO,WAAW,OAAO,CAAC;YAE9B,iCAAiC;YACjC,IAAI,KAAK,SAAS,EAAE;gBAClB,IAAI,YAAY,KAAK,SAAS,CAAC,KAAK,CAAC,GAAG,OAAO,MAAM;gBACrD,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,WAAW,YAAY,GAAG;oBAClD,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,IAAI,CAAC,SAAS,KAAK,QACzC,OAAO,CAAA,GAAA,mBAAW,EAAE,CAAA,GAAA,oBAAY,EAAE,MAAM,IAAI,CAAC,UAAU,GAAG,GAAG;oBAG/D,OAAO,KAAK,GAAG;gBACjB;YACF;YAEA,MAAM,IAAI,CAAC,WAAW,CAAC;YAEvB,sDAAsD;YACtD,IAAI,OAAO,QAAQ,CAAC,YAAY;gBAC9B,MAAM,IAAI,CAAC,WAAW;gBACtB,aAAa;YACf;QACF;QAEA,OAAO;IACT;IA9VA,YAAY,OAA0C,CAAE;QACtD,IAAI,CAAC,UAAU,GAAG,QAAQ,UAAU;QACpC,IAAI,CAAC,YAAY,GAAG,QAAQ,YAAY;QACxC,IAAI,CAAC,gBAAgB,GAAG,QAAQ,gBAAgB,IAAI;QACpD,IAAI,CAAC,GAAG,GAAG,QAAQ,GAAG;QACtB,IAAI,CAAC,SAAS,GAAG,QAAQ,SAAS;QAClC,IAAI,CAAC,QAAQ,GAAG,QAAQ,QAAQ;QAChC,IAAI,CAAC,MAAM,GAAG,QAAQ,MAAM;QAC5B,IAAI,CAAC,SAAS,GAAG,QAAQ,SAAS,IAAI;IACxC;AAsVF","sources":["packages/@react-aria/grid/src/GridKeyboardDelegate.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Direction, DisabledBehavior, Key, KeyboardDelegate, Node} from '@react-types/shared';\nimport {getChildNodes, getFirstItem, getLastItem, getNthItem} from '@react-stately/collections';\nimport {GridCollection} from '@react-types/grid';\nimport {Layout, Rect} from '@react-stately/virtualizer';\nimport {RefObject} from 'react';\n\nexport interface GridKeyboardDelegateOptions<T, C> {\n  collection: C,\n  disabledKeys: Set<Key>,\n  disabledBehavior?: DisabledBehavior,\n  ref?: RefObject<HTMLElement>,\n  direction: Direction,\n  collator?: Intl.Collator,\n  layout?: Layout<Node<T>>,\n  focusMode?: 'row' | 'cell'\n}\n\nexport class GridKeyboardDelegate<T, C extends GridCollection<T>> implements KeyboardDelegate {\n  collection: C;\n  protected disabledKeys: Set<Key>;\n  protected disabledBehavior: DisabledBehavior;\n  protected ref: RefObject<HTMLElement>;\n  protected direction: Direction;\n  protected collator: Intl.Collator;\n  protected layout: Layout<Node<T>>;\n  protected focusMode;\n\n  constructor(options: GridKeyboardDelegateOptions<T, C>) {\n    this.collection = options.collection;\n    this.disabledKeys = options.disabledKeys;\n    this.disabledBehavior = options.disabledBehavior || 'all';\n    this.ref = options.ref;\n    this.direction = options.direction;\n    this.collator = options.collator;\n    this.layout = options.layout;\n    this.focusMode = options.focusMode || 'row';\n  }\n\n  protected isCell(node: Node<T>) {\n    return node.type === 'cell';\n  }\n\n  protected isRow(node: Node<T>) {\n    return node.type === 'row' || node.type === 'item';\n  }\n\n  private isDisabled(item: Node<unknown>) {\n    return this.disabledBehavior === 'all' && (item.props?.isDisabled || this.disabledKeys.has(item.key));\n  }\n\n  protected findPreviousKey(fromKey?: Key, pred?: (item: Node<T>) => boolean) {\n    let key = fromKey != null\n      ? this.collection.getKeyBefore(fromKey)\n      : this.collection.getLastKey();\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!this.isDisabled(item) && (!pred || pred(item))) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  protected findNextKey(fromKey?: Key, pred?: (item: Node<T>) => boolean) {\n    let key = fromKey != null\n      ? this.collection.getKeyAfter(fromKey)\n      : this.collection.getFirstKey();\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!this.isDisabled(item) && (!pred || pred(item))) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyBelow(key: Key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) {\n      return;\n    }\n\n    // If focus was on a cell, start searching from the parent row\n    if (this.isCell(startItem)) {\n      key = startItem.parentKey;\n    }\n\n    // Find the next item\n    key = this.findNextKey(key);\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the next row.\n      if (this.isCell(startItem)) {\n        let item = this.collection.getItem(key);\n        return getNthItem(getChildNodes(item, this.collection), startItem.index).key;\n      }\n\n      // Otherwise, focus the next row\n      if (this.focusMode === 'row') {\n        return key;\n      }\n    }\n  }\n\n  getKeyAbove(key: Key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) {\n      return;\n    }\n\n    // If focus is on a cell, start searching from the parent row\n    if (this.isCell(startItem)) {\n      key = startItem.parentKey;\n    }\n\n    // Find the previous item\n    key = this.findPreviousKey(key);\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the previous row.\n      if (this.isCell(startItem)) {\n        let item = this.collection.getItem(key);\n        return getNthItem(getChildNodes(item, this.collection), startItem.index).key;\n      }\n\n      // Otherwise, focus the previous row\n      if (this.focusMode === 'row') {\n        return key;\n      }\n    }\n  }\n\n  getKeyRightOf(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      return;\n    }\n\n    // If focus is on a row, focus the first child cell.\n    if (this.isRow(item)) {\n      let children = getChildNodes(item, this.collection);\n      return this.direction === 'rtl'\n        ? getLastItem(children).key\n        : getFirstItem(children).key;\n    }\n\n    // If focus is on a cell, focus the next cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item)) {\n      let parent = this.collection.getItem(item.parentKey);\n      let children = getChildNodes(parent, this.collection);\n      let next = this.direction === 'rtl'\n        ? getNthItem(children, item.index - 1)\n        : getNthItem(children, item.index + 1);\n\n      if (next) {\n        return next.key;\n      }\n\n      // focus row only if focusMode is set to row\n      if (this.focusMode === 'row') {\n        return item.parentKey;\n      }\n\n      return this.direction === 'rtl' ? this.getFirstKey(key) : this.getLastKey(key);\n    }\n  }\n\n  getKeyLeftOf(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      return;\n    }\n\n    // If focus is on a row, focus the last child cell.\n    if (this.isRow(item)) {\n      let children = getChildNodes(item, this.collection);\n      return this.direction === 'rtl'\n        ? getFirstItem(children).key\n        : getLastItem(children).key;\n    }\n\n    // If focus is on a cell, focus the previous cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item)) {\n      let parent = this.collection.getItem(item.parentKey);\n      let children = getChildNodes(parent, this.collection);\n      let prev = this.direction === 'rtl'\n        ? getNthItem(children, item.index + 1)\n        : getNthItem(children, item.index - 1);\n\n      if (prev) {\n        return prev.key;\n      }\n\n      // focus row only if focusMode is set to row\n      if (this.focusMode === 'row') {\n        return item.parentKey;\n      }\n\n      return this.direction === 'rtl' ? this.getLastKey(key) : this.getFirstKey(key);\n    }\n  }\n\n  getFirstKey(key?: Key, global?: boolean) {\n    let item: Node<T>;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) {\n        return;\n      }\n\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the first cell in the parent row.\n      if (this.isCell(item) && !global) {\n        let parent = this.collection.getItem(item.parentKey);\n        return getFirstItem(getChildNodes(parent, this.collection)).key;\n      }\n    }\n\n    // Find the first row\n    key = this.findNextKey();\n\n    // If global flag is set (or if focus mode is cell), focus the first cell in the first row.\n    if ((key != null && item && this.isCell(item) && global) || this.focusMode === 'cell') {\n      let item = this.collection.getItem(key);\n      key = getFirstItem(getChildNodes(item, this.collection)).key;\n    }\n\n    // Otherwise, focus the row itself.\n    return key;\n  }\n\n  getLastKey(key?: Key, global?: boolean) {\n    let item: Node<T>;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) {\n        return;\n      }\n\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the last cell in the parent row.\n      if (this.isCell(item) && !global) {\n        let parent = this.collection.getItem(item.parentKey);\n        let children = getChildNodes(parent, this.collection);\n        return getLastItem(children).key;\n      }\n    }\n\n    // Find the last row\n    key = this.findPreviousKey();\n\n    // If global flag is set (or if focus mode is cell), focus the last cell in the last row.\n    if ((key != null && item && this.isCell(item) && global) || this.focusMode === 'cell') {\n      let item = this.collection.getItem(key);\n      let children = getChildNodes(item, this.collection);\n      key = getLastItem(children).key;\n    }\n\n    // Otherwise, focus the row itself.\n    return key;\n  }\n\n  private getItem(key: Key): HTMLElement {\n    return this.ref.current.querySelector(`[data-key=\"${CSS.escape(key.toString())}\"]`);\n  }\n\n  private getItemRect(key: Key): Rect {\n    if (this.layout) {\n      return this.layout.getLayoutInfo(key)?.rect;\n    }\n\n    let item = this.getItem(key);\n    if (item) {\n      return new Rect(item.offsetLeft, item.offsetTop, item.offsetWidth, item.offsetHeight);\n    }\n  }\n\n  private getPageHeight(): number {\n    if (this.layout) {\n      return this.layout.virtualizer?.visibleRect.height;\n    }\n\n    return this.ref?.current?.offsetHeight;\n  }\n\n  private getContentHeight(): number {\n    if (this.layout) {\n      return this.layout.getContentSize().height;\n    }\n\n    return this.ref?.current?.scrollHeight;\n  }\n\n  getKeyPageAbove(key: Key) {\n    let itemRect = this.getItemRect(key);\n    if (!itemRect) {\n      return null;\n    }\n\n    let pageY = Math.max(0, itemRect.maxY - this.getPageHeight());\n\n    while (itemRect && itemRect.y > pageY) {\n      key = this.getKeyAbove(key);\n      itemRect = this.getItemRect(key);\n    }\n\n    return key;\n  }\n\n  getKeyPageBelow(key: Key) {\n    let itemRect = this.getItemRect(key);\n\n    if (!itemRect) {\n      return null;\n    }\n\n    let pageHeight = this.getPageHeight();\n    let pageY = Math.min(this.getContentHeight(), itemRect.y + pageHeight);\n\n    while (itemRect && itemRect.maxY < pageY) {\n      let nextKey = this.getKeyBelow(key);\n      itemRect = this.getItemRect(nextKey);\n\n      // Guard against case where maxY of the last key is barely less than pageY due to rounding\n      // and thus it attempts to set key to null\n      if (nextKey != null) {\n        key = nextKey;\n      }\n    }\n\n    return key;\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey ?? this.getFirstKey();\n\n    // If the starting key is a cell, search from its parent row.\n    let startItem = collection.getItem(key);\n    if (startItem.type === 'cell') {\n      key = startItem.parentKey;\n    }\n\n    let hasWrapped = false;\n    while (key != null) {\n      let item = collection.getItem(key);\n\n      // check row text value for match\n      if (item.textValue) {\n        let substring = item.textValue.slice(0, search.length);\n        if (this.collator.compare(substring, search) === 0) {\n          if (this.isRow(item) && this.focusMode === 'cell') {\n            return getFirstItem(getChildNodes(item, this.collection)).key;\n          }\n\n          return item.key;\n        }\n      }\n\n      key = this.findNextKey(key);\n\n      // Wrap around when reaching the end of the collection\n      if (key == null && !hasWrapped) {\n        key = this.getFirstKey();\n        hasWrapped = true;\n      }\n    }\n\n    return null;\n  }\n}\n"],"names":[],"version":3,"file":"GridKeyboardDelegate.module.js.map"}